"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
// This file was generated by a tool. Modifying this file will produce unexpected behavior.
//
// This script contains functions used by CI build steps.
const childProcess = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");
exports.RUSH_JSON_FILENAME = 'rush.json';
const INSTALLED_FLAG_FILENAME = 'installed.flag';
const NODE_MODULES_FOLDER_NAME = 'node_modules';
const PACKAGE_JSON_FILENAME = 'package.json';
let _npmPath = undefined;
/**
 * Get the absolute path to the npm executable
 */
function getNpmPath() {
    if (!_npmPath) {
        try {
            if (os.platform() === 'win32') {
                // We're on Windows
                const whereOutput = childProcess.execSync('where npm', { stdio: [] }).toString();
                const lines = whereOutput.split(os.EOL).filter((line) => !!line);
                _npmPath = lines[lines.length - 1];
            }
            else {
                // We aren't on Windows - assume we're on *NIX or Darwin
                _npmPath = childProcess.execSync('which npm', { stdio: [] }).toString();
            }
        }
        catch (e) {
            throw new Error(`Unable to determine the path to the NPM tool: ${e}`);
        }
        _npmPath = _npmPath.trim();
        console.log(`NPM executable is '${_npmPath}'`);
        if (!fs.existsSync(_npmPath)) {
            throw new Error('The NPM executable does not exist');
        }
    }
    return _npmPath;
}
exports.getNpmPath = getNpmPath;
let _rushJsonFolder;
/**
 * Find the absolute path to the folder containing rush.json
 */
function findRushJsonFolder() {
    if (!_rushJsonFolder) {
        let basePath = __dirname;
        let tempPath = __dirname;
        do {
            const testRushJsonPath = path.join(basePath, exports.RUSH_JSON_FILENAME);
            if (fs.existsSync(testRushJsonPath)) {
                _rushJsonFolder = basePath;
                break;
            }
            else {
                basePath = tempPath;
            }
        } while (basePath !== (tempPath = path.resolve(basePath, '..'))); // Exit the loop when we hit the disk root
        if (!_rushJsonFolder) {
            throw new Error('Unable to find rush.json.');
        }
    }
    return _rushJsonFolder;
}
exports.findRushJsonFolder = findRushJsonFolder;
/**
 * Create missing directories under the specified base directory, and return the resolved directory.
 *
 * Does not support "." or ".." path segments.
 * Assumes the baseFolder exists.
 */
function ensureAndResolveFolder(baseFolder, ...pathSegments) {
    let resolvedDirectory = baseFolder;
    try {
        for (let pathSegment of pathSegments) {
            pathSegment = pathSegment.replace(/[\\\/]/g, '_');
            resolvedDirectory = path.resolve(resolvedDirectory, pathSegment);
            if (!fs.existsSync(resolvedDirectory)) {
                fs.mkdirSync(resolvedDirectory);
            }
        }
    }
    catch (e) {
        throw new Error(`Error building local installation directory (${path.resolve(baseFolder, ...pathSegments)}): ${e}`);
    }
    return resolvedDirectory;
}
function copyNpmrcIfItExists(rushCommonFolder, packageInstallFolder) {
    const npmrcPath = path.join(rushCommonFolder, 'config', 'rush', '.npmrc');
    const packageInstallNpmrcPath = path.join(packageInstallFolder, '.npmrc');
    if (fs.existsSync(npmrcPath)) {
        try {
            let npmrcFileLines = fs.readFileSync(npmrcPath).toString().split('\n');
            npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());
            const resultLines = [];
            // Trim out lines that reference environment variables that aren't defined
            for (const line of npmrcFileLines) {
                const regex = /\$\{([^\}]+)\}/g; // This finds environment variable tokens that look like "${VAR_NAME}"
                const environmentVariables = line.match(regex);
                let lineShouldBeTrimmed = false;
                if (environmentVariables) {
                    for (const token of environmentVariables) {
                        // Remove the leading "${" and the trailing "}" from the token
                        const environmentVariableName = token.substring(2, token.length - 1);
                        if (!process.env[environmentVariableName]) {
                            lineShouldBeTrimmed = true;
                            break;
                        }
                    }
                }
                if (!lineShouldBeTrimmed) {
                    resultLines.push(line);
                }
            }
            fs.writeFileSync(packageInstallNpmrcPath, resultLines.join(os.EOL));
        }
        catch (e) {
            throw new Error(`Error reading or writing .npmrc file: ${e}`);
        }
    }
}
/**
 * Detects if the package in the specified directory is installed
 */
function isPackageAlreadyInstalled(packageInstallFolder) {
    try {
        const flagFilePath = path.join(packageInstallFolder, INSTALLED_FLAG_FILENAME);
        if (!fs.existsSync(flagFilePath)) {
            return false;
        }
        const fileContents = fs.readFileSync(flagFilePath).toString();
        return fileContents.trim() === process.version;
    }
    catch (e) {
        return false;
    }
}
/**
 * Removes the installed.flag file and the node_modules folder under the specified folder path.
 */
function cleanInstallFolder(rushCommonFolder, packageInstallFolder) {
    try {
        const flagFile = path.resolve(packageInstallFolder, INSTALLED_FLAG_FILENAME);
        if (fs.existsSync(flagFile)) {
            fs.unlinkSync(flagFile);
        }
        const nodeModulesFolder = path.resolve(packageInstallFolder, NODE_MODULES_FOLDER_NAME);
        if (fs.existsSync(nodeModulesFolder)) {
            const rushRecyclerFolder = ensureAndResolveFolder(rushCommonFolder, 'temp', 'rush-recycler', Date.now().toString());
            fs.renameSync(nodeModulesFolder, rushRecyclerFolder);
        }
    }
    catch (e) {
        throw new Error(`Error cleaning the package install folder (${packageInstallFolder}): ${e}`);
    }
}
function createPackageJason(packageInstallFolder, name, version) {
    try {
        const packageJsonContents = {
            'name': 'ci-rush',
            'version': '0.0.0',
            'dependencies': {
                [name]: version
            },
            'description': 'DON\'T WARN',
            'repository': 'DON\'T WARN',
            'license': 'MIT'
        };
        const packageJsonPath = path.join(packageInstallFolder, PACKAGE_JSON_FILENAME);
        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJsonContents, undefined, 2));
    }
    catch (e) {
        throw new Error(`Unable to create package.json: ${e}`);
    }
}
/**
 * Run "npm install" in the package install folder.
 */
function installPackage(packageInstallFolder, name, version) {
    try {
        console.log(`Installing ${name}...`);
        const npmPath = getNpmPath();
        childProcess.execSync(`"${npmPath}" install`, { cwd: packageInstallFolder });
        console.log(`Successfully installed ${name}@${version}`);
    }
    catch (e) {
        throw new Error(`Unable to install package: ${e}`);
    }
}
/**
 * Try to resolve the specified binary in an installed package.
 */
function findBinPath(packageInstallFolder, name, binName) {
    try {
        const packagePath = path.resolve(packageInstallFolder, NODE_MODULES_FOLDER_NAME, name);
        const packageJsonPath = path.resolve(packagePath, PACKAGE_JSON_FILENAME);
        const packageJson = require(packageJsonPath);
        if (!packageJson.bin) {
            throw new Error('No binaries are specified for package.');
        }
        else {
            const binValue = packageJson.bin[binName];
            if (!binValue) {
                throw new Error(`Binary ${binName} is not specified in the package's package.json`);
            }
            else {
                const resolvedBinPath = path.resolve(packagePath, binValue);
                if (!fs.existsSync(resolvedBinPath)) {
                    throw new Error('The specified binary points to a path that does not exist');
                }
                else {
                    return resolvedBinPath;
                }
            }
        }
    }
    catch (e) {
        throw new Error(`Unable to find specified binary "${binName}": ${e}`);
    }
}
/**
 * Write a flag file to the package's install directory, signifying that the install was successful.
 */
function writeFlagFile(packageInstallFolder) {
    try {
        const flagFilePath = path.join(packageInstallFolder, INSTALLED_FLAG_FILENAME);
        fs.writeFileSync(flagFilePath, process.version);
    }
    catch (e) {
        // Ignore
    }
}
function installAndRun(nodePath, packageName, packageVersion, packageBinName, packageBinArgs) {
    const rushJsonFolder = findRushJsonFolder();
    const rushCommonFolder = path.join(rushJsonFolder, 'common');
    const packageInstallFolder = ensureAndResolveFolder(rushCommonFolder, 'temp', 'install-run', `${packageName}@${packageVersion}`);
    if (!isPackageAlreadyInstalled(packageInstallFolder)) {
        // The package isn't already installed
        cleanInstallFolder(rushCommonFolder, packageInstallFolder);
        copyNpmrcIfItExists(rushCommonFolder, packageInstallFolder);
        createPackageJason(packageInstallFolder, packageName, packageVersion);
        installPackage(packageInstallFolder, packageName, packageVersion);
        writeFlagFile(packageInstallFolder);
    }
    const binPath = findBinPath(packageInstallFolder, packageName, packageBinName);
    childProcess.spawnSync(nodePath, [binPath, ...packageBinArgs], {
        stdio: 'inherit',
        cwd: process.cwd(),
        env: process.env
    });
}
exports.installAndRun = installAndRun;
function runWithErrorPrinting(fn) {
    try {
        fn();
    }
    catch (e) {
        console.error(os.EOL + os.EOL + e.toString() + os.EOL + os.EOL);
    }
}
exports.runWithErrorPrinting = runWithErrorPrinting;

//# sourceMappingURL=install-run-common.js.map
