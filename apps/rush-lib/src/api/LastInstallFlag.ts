import * as path from 'path';
import * as _ from 'lodash';
import { FileSystem, JsonFile, JsonObject } from '@microsoft/node-core-library';

export const LAST_INSTALL_FLAG_FILE_NAME: string = 'last-install.flag';

interface IPropertyErrors {
  /** The properties to check and force an abort on inequality */
  [key: string]: {
    /**
     * List of additional properties between both states that must match
     * in order to abort with an error
     */
    deps?: string[];
    /** The error to throw if conditions are met */
    error: string;
  };
}

/** @internal */
interface ILastInstallFlagErrorState {
  oldState: JsonObject;
  newState: JsonObject;
}

/**
 * Provides error checking utilities, and defines an `Error` of type `LastInstallFlagError`
 * that can be generated by `LastInstallFlag` when it is desired.
 * 
 * If `LastInstallFlag.isValid` is called with `abortOnInvalid = true`, then the properties
 * in `LastInstallFlagError._errors` will be used to find which properties between the old
 * and new `LastInstallFlag` states are not equal, and then generate a friendly error for 
 * that particular property.
 * @internal
 */
export class LastInstallFlagError extends Error {
  /**
   * Collection of properties that can generate an error if an inequality
   * is detected between old & new state.
   * If `deps` are defined for a property, all of those properties must match
   * between old & new state in order for the error message to be generated.
   */
  private static _errors: IPropertyErrors = {
    storePath: {
      error: "Current PNPM store path does not match the last one used.  This may cause inconsistency in your builds.\n\n" +
      "If you wish to install with the new store path, please run \"rush update --purge\"",
      deps: ["packageManager"]
    }
  }
  
  /**
   * Creates a new LastInstallFlagError
   * @param errorKey - The error to generate
   * @param state - Object containing the old and new LastInstallFlag state
   * @internal
   */
  private constructor(errorKey: string, state: ILastInstallFlagErrorState) {
    super();

    switch (errorKey) {
      case 'storePath': {
        const oldStorePath: string = state.oldState.storePath || '<global>';
        const newStorePath: string = state.newState.storePath || '<global>';
        this.message = 
          `${LastInstallFlagError._getError(errorKey)}\n\n` +
          `Old Path: ${oldStorePath}\n` +
          `New Path: ${newStorePath}`
        break;
      }
      default: {
        // simply set the error message to the one defined in the _errors
        // object
        if (LastInstallFlagError._getError(errorKey)) {
          this.message = LastInstallFlagError._getError(errorKey);
        } else {
          // the `errorKey` didn't have an error key defined.  Throw an Error
          // so the developer knows.
          throw new Error(`LastInstallFlagError: an invalid 'errorKey' was defined\nThe key '${errorKey}' does not have an error message defined`);
        }
        break;
      }
    }
  }

  /**
   * Generates a new LastInstallFlagError if error state exists for the defined
   * `errorKey`, and if the dependencies for generating that error are met.
   * @param errorKey - The property of LastInstallFlag to get error state for
   * @param state - Object containing the old and new LastInstallFlag state
   */
  public static newError(errorKey: string, state: ILastInstallFlagErrorState): LastInstallFlagError | void {
    // Do not generate error if one is not defined
    if (!LastInstallFlagError._getError(errorKey)) return;
    // Do not generate an error if dependencies are not met
    if (!LastInstallFlagError._checkDeps(errorKey, state)) return;
    return new LastInstallFlagError(errorKey, state);
  }

  /**
   * Verify that the dependencies for the chosen errorKey are met
   * @param errorKey - Check dependencies for this error key
   * @param state - Object containing the old and new LastInstallFlag state
   */
  private static _checkDeps(errorKey: string, state: ILastInstallFlagErrorState): boolean {
    const depKeys: string[] = LastInstallFlagError._getDeps(errorKey);
    const depsMatch: boolean = depKeys.length === 0 || depKeys.every(
      (depProp) => _.isEqual(state.oldState[depProp], state.newState[depProp])
    );
    return !_.isEqual(state.oldState[errorKey], state.newState[errorKey]) && depsMatch;
  }

  /**
   * Returns the error message for the defined `errorKey`.  If there is none,
   * an empty string will be returned.
   * @param errorKey - error key to get the error message for
   */
  private static _getError(errorKey: string): string {
    return (
      LastInstallFlagError._errors[errorKey] 
      && LastInstallFlagError._errors[errorKey].error
    ) || '';
  }

  /**
   * Returns the list of dependency properties for the defined `errorKey`.
   * If there are none, an empty array will be returned.
   * @param errorKey - error key to get dependencies for
   */
  private static _getDeps(errorKey: string): string[] {
    return LastInstallFlagError._errors[errorKey].deps || [];
  }

  /**
   * Returns the list of properties that have errors defined for them
   */
  public static get checkProps(): string[] {
    return Object.keys(LastInstallFlagError._errors) || [];
  }
}

/**
 * A helper class for managing last-install flags, which are persistent and
 * indicate that something installed in the folder was sucessfully completed.
 * It also compares state, so that if something like the Node.js version has changed,
 * it can invalidate the last install.
 * @internal
 */
export class LastInstallFlag {
  private _path: string;
  private _state: JsonObject;

  /**
   * Creates a new LastInstall flag
   * @param folderPath - the folder that this flag is managing
   * @param state - optional, the state that should be managed or compared
  */
  public constructor(folderPath: string, state: JsonObject = {}) {
    this._path = path.join(folderPath, LAST_INSTALL_FLAG_FILE_NAME);
    this._state = state;
  }

  /**
   * Returns true if the file exists and the contents match the current state
   * @param abortOnInvalid - If the current state is not equal to the previous
   * state, and an error is defined for the condition that causes inequality, then abort with
   * the defined error message
   */
  public isValid(abortOnInvalid: boolean = false): boolean {
    if (!FileSystem.exists(this._path)) {
      return false;
    }
    let contents: JsonObject;
    try {
      contents = JsonFile.load(this._path);
    } catch (err) {
      return false;
    } 
    if (!_.isEqual(contents, this._state)) {
      if (abortOnInvalid) {
        LastInstallFlagError.checkProps.forEach((errKey) => {
          const flagError: LastInstallFlagError | void = LastInstallFlagError.newError(errKey, {
            oldState: contents,
            newState: this._state
          });
          if (flagError) {
            throw flagError;
          }
        })
      }
      return false;
    }
    return true;
  }

  /**
   * Writes the flag file to disk with the current state
   */
  public create(): void {
    JsonFile.save(this._state, this._path, {
      ensureFolderExists: true
    });
  }

  /**
   * Removes the flag file
   */
  public clear(): void {
    FileSystem.deleteFile(this._path);
  }

  /**
   * Returns the full path to the flag file
   */
  public get path(): string {
    return this._path;
  }
}