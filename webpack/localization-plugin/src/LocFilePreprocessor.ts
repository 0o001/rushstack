// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

import {
  FileSystem,
  JsonFile,
  JsonSchema,
  Terminal,
  ConsoleTerminalProvider
} from '@microsoft/node-core-library';
import * as glob from 'glob';
import * as path from 'path';
import { EOL } from 'os';

import { ILocFile } from './interfaces';
import { ResxReader, ILogger } from './utilities/ResxReader';

/**
 * @public
 */
export interface ILocFilePreprocessorOptions {
  srcFolder: string;
  generatedTsFolder: string;
  terminal: Terminal;
  filesToIgnore?: string[];
}

/**
 * This is a simple tool that generates .d.ts files for .loc.json and .resx files.
 *
 * @public
 */
export class LocFilePreprocessor {
  private _options: ILocFilePreprocessorOptions;
  private _loggingOptions: ILogger;

  public constructor(options: ILocFilePreprocessorOptions) {
    this._options = {
      filesToIgnore: [],
      ...options
    };

    if (this._options.terminal) {
      this._options.terminal = new Terminal(new ConsoleTerminalProvider({ verboseEnabled: true }));
    }

    function logWithLocation(
      loggingFn: typeof Terminal.prototype.writeErrorLine,
      message: string,
      filePath: string,
      line?: number,
      position?: number
    ): void {
      let location: string;
      if (position !== undefined) {
        location = `${filePath}(${line},${position})`;
      } else if (line !== undefined) {
        location = `${filePath}(${line})`;
      } else {
        location = filePath;
      }

      loggingFn(`${location}: ${message}`);
    }

    this._loggingOptions = {
      logError: (message: string) => this._options.terminal.writeErrorLine(message),
      logWarning: (message: string) => this._options.terminal.writeWarningLine(message),
      logFileError: (message: string, filePath: string, line?: number, position?: number) => {
        logWithLocation(
          this._options.terminal.writeErrorLine.bind(this._options.terminal),
          message,
          filePath,
          line,
          position
        );
      },
      logFileWarning: (message: string, filePath: string, line?: number, position?: number) => {
        logWithLocation(
          this._options.terminal.writeWarningLine.bind(this._options.terminal),
          message,
          filePath,
          line,
          position
        );
      }
    }
  }

  public generateTypings(): void {
    FileSystem.ensureEmptyFolder(this._options.generatedTsFolder);

    const filesToIgnore: Set<string> = new Set<string>((this._options.filesToIgnore!).map((fileToIgnore) => {
      if (path.isAbsolute(fileToIgnore)) {
        return fileToIgnore;
      } else {
        return path.resolve(this._options.srcFolder, fileToIgnore);
      }
    }));

    const locJsonFiles: string[] = glob.sync(
      path.join('**', '*.loc.json'),
      {
        root: this._options.srcFolder,
        absolute: true
      }
    );

    const locJsonSchema: JsonSchema = JsonSchema.fromFile(path.resolve(__dirname, 'schemas', 'locJson.schema.json'));
    for (let locJsonFilePath of locJsonFiles) {
      locJsonFilePath = path.resolve(locJsonFilePath);

      if (filesToIgnore.has(locJsonFilePath)) {
        continue;
      }

      const locFileData: ILocFile = JsonFile.loadAndValidate(locJsonFilePath, locJsonSchema);
      this._generateTypingsForLocFile(locJsonFilePath, locFileData);
    }

    const resxFiles: string[] = glob.sync(
      path.join('**', '*.resx'),
      {
        root: this._options.srcFolder,
        absolute: true
      }
    );

    for (let resxFilePath of resxFiles) {
      resxFilePath = path.resolve(resxFilePath);

      if (filesToIgnore.has(resxFilePath)) {
        continue;
      }

      const locFileData: ILocFile = ResxReader.readResxFileAsLocFile({ ...this._loggingOptions, resxFilePath });
      this._generateTypingsForLocFile(resxFilePath, locFileData);
    }
  }

  private _generateTypingsForLocFile(locFilePath: string, locFileData: ILocFile): void {
    const outputLines: string[] = [
      '// This file was generated by a tool. Modifying it will produce unexpected behavior',
      ''
    ];

    for (const stringName in locFileData) { // eslint-disable-line guard-for-in
      const { comment } = locFileData[stringName];

      if (comment.trim()) {
        outputLines.push(...[
          '/**',
          ` * ${comment.replace(/\*\//g, '*\\/')}`,
          ' */'
        ]);
      }

      outputLines.push(...[
        `export declare const ${stringName}: string;`,
        ''
      ]);
    }

    const generatedTsFilePath: string = path.resolve(
      this._options.generatedTsFolder,
      path.relative(this._options.srcFolder, `${locFilePath}.d.ts`)
    );
    FileSystem.writeFile(generatedTsFilePath, outputLines.join(EOL), { ensureFolderExists: true });
  }
}
